# SFM: A=2 B = 0.5 K=1 without adjustment according to Crowdnav paper
 
# # adjustment = np.abs(self.radius - other_human_state.radius) + 0.01
# delta_x = self_state.px - other_human_state.px
# delta_y = self_state.py - other_human_state.py
# dist_to_human = np.sqrt(delta_x**2 + delta_y**2)
# dist_to_human = max(dist_to_human, 1e-6)  # 避免 0

# interaction_vx += A * np.exp((self_state.radius + other_human_state.radius  - dist_to_human) / B) * (delta_x / dist_to_human)
# interaction_vy += A * np.exp((self_state.radius + other_human_state.radius  - dist_to_human) / B) * (delta_y / dist_to_human)


# vel -2 2
# acc -50 50
# obs vel: use velocity in config.ymal v_des
# std_px and std_py are set to be smaller than ground truth when generate one_obs_cvar_beta_dt_doubleint_v2_gamma0.1_betaNone_hdist_lastframe copy.gif
# def gen_pmf(self, control_input, state, noise, S):
#     if state.shape[0] == 2:
#         std_px, std_py = noise[0]
#         if std_px <= 1e-5 and std_py <= 1e-5:
#             std_px = 0.001
#             std_py = 0.001
#         # std_px = 0.03
#         # std_py = 0.03 